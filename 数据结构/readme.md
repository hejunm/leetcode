# 数据结构

* 数组和链表是基础。 在这两种数据结构基础上 拓展出其他数据结构

## 数组

* 基本数据结构
* 地址空间连续

## 链表

* 基本数据结构
* 地址空间不连续，使用指针连接。
* 单向链表（一个指针指向nextNode）
* 双向链表（两个指针，分别指向preNode、nextNode）
* 双向指针可以用于实现LRU

## 栈 & 队列

* [专题](https://leetcode-cn.com/explore/learn/card/queue-stack/)
* 可以使用数组实现，也可以使用链表实现
* 数组实现：需要解决扩容缩容问题
* 链表实现：不需考虑扩容缩容问题，但需额外的内存空间存储链表指针

## 散列表

* 实现：哈希集合，哈希映射 (Set和Map 也可以使用平衡二叉搜索树实现)
* 通过散列函数 将键映射到一个桶中。（桶：数组 | 链表）
* 散列冲突解决方法：
  * 拉链法：运用链表特性，操作简单。但需要额外的空间存储指针；
  * 线性探查法（开放定址法）：运用数组特性，不需要指针的存储空间，需解决扩容、缩容问题，操作稍微复杂些。

* 内置哈希表的典型设计：
  * 键值可以是任何可哈希化的类型。并且属于可哈希类型的值将具有哈希码。此哈希码将用于映射函数以获取存储区索引。
  * 每个桶包含一个数组，用于在初始时将所有值存储在同一个桶中。
  * 如果在同一个桶中有太多的值，这些值将被保留在一个高度平衡的二叉树搜索树中。
  * 插入和搜索的平均时间复杂度仍为 O(1)。最坏情况下插入和搜索的时间复杂度是 O(logN)，使用高度平衡的 BST。这是在插入和搜索之间的一种权衡。

## 图

* 邻接表: 就是链表，比较节省空间，但很多操作效率上比不过临界矩阵。
* 临界矩阵: 二维数组，可迅速的判断联通性，并可以进行矩阵运算解决一些问题。如果图比较稀疏 很浪费存储空间。
  
## 树

* 数组实现: 实现完全二叉树。用数组存储不需要节点指针，操作简单。堆是一种特殊的完全二叉树 可分为大根堆和小根堆
  * [堆](https://zh.wikipedia.org/wiki/%E5%A0%86%E7%A9%8D)
* 链表实现: 常见的二叉树，由于不一定是完全二叉树，所以不能使用数组存储。
  